# Makefile para Mini-Kernel Educativo usando Docker
# Este Makefile permite compilar el kernel sin instalar herramientas localmente

# ConfiguraciÃ³n
DOCKER_IMAGE = minikernel-dev
DOCKER_TAG = latest
CONTAINER_NAME = minikernel-container
PROJECT_ROOT = $(shell dirname $(PWD))

# Colores para output
GREEN = \033[0;32m
YELLOW = \033[1;33m
RED = \033[0;31m
NC = \033[0m # No Color

# Objetivos principales
.PHONY: help build-image run-container compile run clean debug shell info check-docker

# Objetivo por defecto
all: help

help:
	@echo "$(GREEN)ðŸŽ“ Mini-Kernel Educativo - Docker Build System$(NC)"
	@echo ""
	@echo "$(YELLOW)â­ Comandos principales (Docker + QEMU host):$(NC)"
	@echo "  $(GREEN)setup$(NC)          - Construir imagen Docker (solo primera vez)"
	@echo "  $(GREEN)compile$(NC)        - Compilar kernel en Docker"
	@echo "  $(GREEN)run-gui$(NC)        - Compilar en Docker + Ejecutar en QEMU host (â­ SIN XQuartz)"
	@echo "  $(GREEN)run-debug-host$(NC) - Compilar en Docker + Debug en terminal host"
	@echo ""
	@echo "$(YELLOW)ðŸ³ Comandos solo Docker (requiere X11):$(NC)"
	@echo "  $(GREEN)run-debug$(NC)      - Ejecutar con salida serial en Docker"
	@echo "  $(GREEN)run-gui-linux$(NC)  - GUI con X11 forwarding (Linux)"
	@echo "  $(GREEN)run-gui-macos$(NC)  - GUI con XQuartz (macOS)"
	@echo ""
	@echo "$(YELLOW)ðŸ”§ Herramientas:$(NC)"
	@echo "  $(GREEN)shell$(NC)          - Shell interactivo en contenedor"
	@echo "  $(GREEN)debug$(NC)          - Ejecutar con soporte GDB"
	@echo "  $(GREEN)clean$(NC)          - Limpiar archivos compilados"
	@echo "  $(GREEN)info$(NC)           - InformaciÃ³n del entorno"
	@echo ""
	@echo "$(YELLOW)ðŸš€ Uso tÃ­pico (configuraciÃ³n automÃ¡tica):$(NC)"
	@echo "  1. $(GREEN)make setup-all$(NC)    # Configura todo automÃ¡ticamente"
	@echo "  2. $(GREEN)make run-gui$(NC)      # Â¡Compilar y ejecutar!"
	@echo ""
	@echo "$(YELLOW)ðŸ”§ ConfiguraciÃ³n manual:$(NC)"
	@echo "  1. $(GREEN)make setup$(NC)        # Solo Docker (10-15 min)"
	@echo "  2. $(GREEN)make install-qemu$(NC) # Solo QEMU"
	@echo "  3. $(GREEN)make run-gui$(NC)      # Ejecutar"
	@echo ""
	@echo "$(YELLOW)ðŸ“‹ Requisitos:$(NC)"
	@echo "  - Docker (ya instalado âœ…)"
	@echo "  - QEMU: automÃ¡tico con $(GREEN)make setup-all$(NC)"
	@echo ""

# Verificar que Docker estÃ© disponible
check-docker:
	@which docker > /dev/null || (echo "$(RED)âŒ Docker no estÃ¡ instalado$(NC)" && exit 1)
	@docker info > /dev/null 2>&1 || (echo "$(RED)âŒ Docker no estÃ¡ ejecutÃ¡ndose$(NC)" && exit 1)

# Verificar que QEMU estÃ© disponible en el host
check-qemu-host:
	@which qemu-system-i386 > /dev/null || (echo "$(RED)âŒ QEMU no estÃ¡ instalado en el host$(NC)" && \
		echo "$(YELLOW)ðŸ’¡ Instala QEMU:$(NC)" && \
		echo "$(YELLOW)   macOS: brew install qemu$(NC)" && \
		echo "$(YELLOW)   Ubuntu: sudo apt install qemu-system-x86$(NC)" && \
		echo "$(YELLOW)   O ejecuta: make install-qemu$(NC)" && \
		echo "$(YELLOW)   O usa: make run-debug (sin GUI)$(NC)" && exit 1)

# Instalar QEMU automÃ¡ticamente
install-qemu:
	@echo "$(YELLOW)ðŸ”§ Instalando QEMU...$(NC)"
	@if [ "$$(uname)" = "Darwin" ]; then \
		if command -v brew >/dev/null 2>&1; then \
			echo "$(YELLOW)ðŸº Usando Homebrew para instalar QEMU...$(NC)"; \
			brew install qemu; \
		else \
			echo "$(RED)âŒ Homebrew no estÃ¡ instalado$(NC)"; \
			echo "$(YELLOW)ðŸ’¡ Instala Homebrew desde: https://brew.sh/$(NC)"; \
			echo "$(YELLOW)ðŸ’¡ O instala QEMU manualmente$(NC)"; \
			exit 1; \
		fi \
	elif [ "$$(uname)" = "Linux" ]; then \
		echo "$(YELLOW)ðŸ§ Detectado Linux...$(NC)"; \
		if command -v apt >/dev/null 2>&1; then \
			echo "$(YELLOW)ðŸ“¦ Usando apt para instalar QEMU...$(NC)"; \
			sudo apt update && sudo apt install -y qemu-system-x86; \
		elif command -v yum >/dev/null 2>&1; then \
			echo "$(YELLOW)ðŸ“¦ Usando yum para instalar QEMU...$(NC)"; \
			sudo yum install -y qemu-system-x86; \
		else \
			echo "$(RED)âŒ Gestor de paquetes no soportado$(NC)"; \
			exit 1; \
		fi \
	else \
		echo "$(RED)âŒ Sistema operativo no soportado$(NC)"; \
		exit 1; \
	fi
	@echo "$(GREEN)âœ… QEMU instalado correctamente$(NC)"

# ConfiguraciÃ³n completa automÃ¡tica
setup-all: check-docker
	@echo "$(GREEN)ðŸš€ ConfiguraciÃ³n completa del entorno Mini-Kernel$(NC)"
	@echo "$(YELLOW)ðŸ“¦ Paso 1/2: Configurando Docker...$(NC)"
	@$(MAKE) setup
	@echo "$(YELLOW)ðŸ“¦ Paso 2/2: Instalando QEMU...$(NC)"
	@if ! command -v qemu-system-i386 >/dev/null 2>&1; then \
		$(MAKE) install-qemu; \
	else \
		echo "$(GREEN)âœ… QEMU ya estÃ¡ instalado$(NC)"; \
	fi
	@echo ""
	@echo "$(GREEN)ðŸŽ‰ Â¡CONFIGURACIÃ“N COMPLETA!$(NC)"
	@echo "$(YELLOW)ðŸ’¡ Ahora puedes usar:$(NC)"
	@echo "  $(GREEN)make run-gui$(NC)    # Compilar y ejecutar con ventana"
	@echo "  $(GREEN)make compile$(NC)    # Solo compilar"
	@echo ""

# Construir imagen Docker
setup: check-docker
	@echo "$(YELLOW)ðŸ”¨ Construyendo imagen Docker...$(NC)"
	@echo "$(YELLOW)âš ï¸  Esto puede tomar 10-15 minutos la primera vez$(NC)"
	docker build -t $(DOCKER_IMAGE):$(DOCKER_TAG) .
	@echo "$(GREEN)âœ… Imagen Docker construida exitosamente$(NC)"

# Verificar si la imagen existe
check-image:
	@docker image inspect $(DOCKER_IMAGE):$(DOCKER_TAG) > /dev/null 2>&1 || \
		(echo "$(RED)âŒ Imagen Docker no encontrada. Ejecuta: make setup$(NC)" && exit 1)

# Compilar kernel usando Docker (alias para compile-only)
compile: compile-only
	@echo "$(GREEN)âœ… CompilaciÃ³n completada$(NC)"
	@echo "$(YELLOW)ðŸ’¡ Usa 'make run-gui' para ejecutar con ventana$(NC)"
	@echo "$(YELLOW)ðŸ’¡ Usa 'make run-debug' para ejecutar en terminal$(NC)"

# Ejecutar kernel en QEMU (modo texto)
run: check-docker check-image
	@echo "$(YELLOW)ðŸš€ Ejecutando Mini-Kernel en QEMU (modo texto)...$(NC)"
	@echo "$(YELLOW)ðŸ’¡ Presiona Ctrl+A, luego X para salir de QEMU$(NC)"
	docker run --rm -it \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		make run

# Ejecutar kernel con QEMU del host (sin X11)
run-gui: check-docker check-image check-qemu-host
	@echo "$(YELLOW)ðŸš€ Compilando en Docker, ejecutando en QEMU del host...$(NC)"
	@echo "$(YELLOW)ðŸ’¡ Se abrirÃ¡ ventana de QEMU nativa$(NC)"
	docker run --rm \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		make
	@echo "$(GREEN)âœ… CompilaciÃ³n completada, ejecutando QEMU...$(NC)"
	cd $(PROJECT_ROOT) && qemu-system-i386 -kernel myos.elf -m 32

# Ejecutar GUI forzado (Linux style)
run-gui-linux: check-docker check-image
	@echo "$(YELLOW)ðŸ§ Ejecutando con configuraciÃ³n Linux...$(NC)"
	docker run --rm -it \
		--env="DISPLAY=$${DISPLAY}" \
		--volume="/tmp/.X11-unix:/tmp/.X11-unix:rw" \
		--net=host \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		make run-gui

# Ejecutar GUI forzado (macOS style)
run-gui-macos: check-docker check-image
	@echo "$(YELLOW)ðŸŽ Ejecutando con configuraciÃ³n macOS...$(NC)"
	./run-macos-gui.sh

# Ejecutar kernel con debugging serial (dentro de Docker)
run-debug: check-docker check-image
	@echo "$(YELLOW)ðŸ› Ejecutando kernel con salida de debug...$(NC)"
	@echo "$(YELLOW)ðŸ’¡ Salida serial redirigida a terminal$(NC)"
	docker run --rm -it \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		bash -c "make && qemu-system-i386 -kernel myos.elf -m 32 -display none -serial stdio"

# Ejecutar QEMU en el host con debugging serial
run-debug-host: check-docker check-image check-qemu-host
	@echo "$(YELLOW)ðŸ› Compilando en Docker, debug en QEMU del host...$(NC)"
	docker run --rm \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		make
	@echo "$(GREEN)âœ… CompilaciÃ³n completada, ejecutando QEMU con debug...$(NC)"
	cd $(PROJECT_ROOT) && qemu-system-i386 -kernel myos.elf -m 32 -nographic

# Solo compilar (sin ejecutar)
compile-only: check-docker check-image
	@echo "$(YELLOW)ðŸ”¨ Solo compilando (sin ejecutar)...$(NC)"
	docker run --rm \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		make

# Ejecutar kernel con debugging
debug: check-docker check-image
	@echo "$(YELLOW)ðŸ› Ejecutando kernel en modo debug...$(NC)"
	@echo "$(YELLOW)ðŸ’¡ GDB conectarÃ¡ en puerto 1234$(NC)"
	@echo "$(YELLOW)ðŸ’¡ En otra terminal: docker exec -it $(CONTAINER_NAME) gdb myos.elf$(NC)"
	docker run --rm -it \
		--name $(CONTAINER_NAME) \
		-p 1234:1234 \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		run-kernel-debug

# Abrir shell interactivo en contenedor
shell: check-docker check-image
	@echo "$(YELLOW)ðŸ–¥ï¸  Abriendo shell en contenedor de desarrollo...$(NC)"
	@echo "$(YELLOW)ðŸ’¡ Usa 'exit' para salir$(NC)"
	docker run --rm -it \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		/bin/bash

# Limpiar archivos compilados
clean: check-docker check-image
	@echo "$(YELLOW)ðŸ§¹ Limpiando archivos compilados...$(NC)"
	docker run --rm \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		make clean
	@echo "$(GREEN)âœ… Archivos limpiados$(NC)"

# Limpiar todo incluyendo imagen Docker
clean-all: clean
	@echo "$(YELLOW)ðŸ—‘ï¸  Eliminando imagen Docker...$(NC)"
	docker rmi $(DOCKER_IMAGE):$(DOCKER_TAG) || true
	@echo "$(GREEN)âœ… Limpieza completa$(NC)"

# Mostrar informaciÃ³n del entorno
info: check-docker
	@echo "$(GREEN)ðŸŽ“ Mini-Kernel Educativo - InformaciÃ³n del Entorno$(NC)"
	@echo ""
	@echo "$(YELLOW)Docker:$(NC)"
	@docker --version
	@echo ""
	@echo "$(YELLOW)Imagen del proyecto:$(NC)"
	@docker image inspect $(DOCKER_IMAGE):$(DOCKER_TAG) > /dev/null 2>&1 && \
		echo "  âœ… $(DOCKER_IMAGE):$(DOCKER_TAG) - Disponible" || \
		echo "  âŒ $(DOCKER_IMAGE):$(DOCKER_TAG) - No encontrada (ejecuta: make setup)"
	@echo ""
	@echo "$(YELLOW)Directorio del proyecto:$(NC)"
	@echo "  ðŸ“ $(PROJECT_ROOT)"
	@echo ""
	@echo "$(YELLOW)Comandos rÃ¡pidos:$(NC)"
	@echo "  ðŸ”¨ make compile  - Compilar kernel"
	@echo "  ðŸš€ make run      - Ejecutar kernel"
	@echo "  ðŸ› make debug    - Debug con GDB"
	@echo "  ðŸ–¥ï¸  make shell    - Shell interactivo"

# Objetivo para verificar herramientas dentro del contenedor
check-tools: check-docker check-image
	@echo "$(YELLOW)ðŸ”§ Verificando herramientas en el contenedor...$(NC)"
	docker run --rm \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		check-environment

# Objetivo para desarrolladores: reconstruir imagen forzadamente
rebuild: check-docker
	@echo "$(YELLOW)ðŸ”„ Reconstruyendo imagen Docker (sin cache)...$(NC)"
	docker build --no-cache -t $(DOCKER_IMAGE):$(DOCKER_TAG) .
	@echo "$(GREEN)âœ… Imagen reconstruida$(NC)"

# Objetivo para ver logs de compilaciÃ³n detallados
verbose-compile: check-docker check-image
	@echo "$(YELLOW)ðŸ”¨ CompilaciÃ³n verbose usando Docker...$(NC)"
	docker run --rm \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		make V=1

# Objetivo para ejecutar tests (si los hay)
test: check-docker check-image
	@echo "$(YELLOW)ðŸ§ª Ejecutando tests...$(NC)"
	docker run --rm \
		-v $(PROJECT_ROOT):/workspace \
		-w /workspace \
		$(DOCKER_IMAGE):$(DOCKER_TAG) \
		bash -c "make clean && make && echo 'Tests bÃ¡sicos: compilaciÃ³n exitosa'"

# Objetivo para generar documentaciÃ³n del entorno
docs:
	@echo "$(GREEN)ðŸ“š DocumentaciÃ³n del Entorno Docker$(NC)" > DOCKER_USAGE.md
	@echo "" >> DOCKER_USAGE.md
	@echo "## InstalaciÃ³n y Uso" >> DOCKER_USAGE.md
	@echo "" >> DOCKER_USAGE.md
	@echo "### Primer Uso" >> DOCKER_USAGE.md
	@echo "\`\`\`bash" >> DOCKER_USAGE.md
	@echo "cd docker-build" >> DOCKER_USAGE.md
	@echo "make setup      # Construir imagen (una sola vez)" >> DOCKER_USAGE.md
	@echo "make compile    # Compilar kernel" >> DOCKER_USAGE.md
	@echo "make run        # Ejecutar kernel" >> DOCKER_USAGE.md
	@echo "\`\`\`" >> DOCKER_USAGE.md
	@echo "" >> DOCKER_USAGE.md
	@echo "### Desarrollo Diario" >> DOCKER_USAGE.md
	@echo "\`\`\`bash" >> DOCKER_USAGE.md
	@echo "make compile    # Recompilar despuÃ©s de cambios" >> DOCKER_USAGE.md
	@echo "make run        # Probar kernel" >> DOCKER_USAGE.md
	@echo "make debug      # Debugging con GDB" >> DOCKER_USAGE.md
	@echo "make shell      # Shell para exploraciÃ³n" >> DOCKER_USAGE.md
	@echo "\`\`\`" >> DOCKER_USAGE.md
	@echo "$(GREEN)âœ… DocumentaciÃ³n generada en DOCKER_USAGE.md$(NC)"

# Limpieza de contenedores huÃ©rfanos
clean-containers:
	@echo "$(YELLOW)ðŸ§¹ Limpiando contenedores Docker huÃ©rfanos...$(NC)"
	@docker container prune -f
	@docker image prune -f
	@echo "$(GREEN)âœ… Contenedores limpiados$(NC)"

# Mostrar tamaÃ±o de la imagen
image-size: check-image
	@echo "$(YELLOW)ðŸ“¦ TamaÃ±o de la imagen Docker:$(NC)"
	@docker image ls $(DOCKER_IMAGE):$(DOCKER_TAG) --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

# Exportar imagen para compartir
export-image: check-image
	@echo "$(YELLOW)ðŸ“¤ Exportando imagen Docker...$(NC)"
	docker save $(DOCKER_IMAGE):$(DOCKER_TAG) | gzip > minikernel-dev.tar.gz
	@echo "$(GREEN)âœ… Imagen exportada como minikernel-dev.tar.gz$(NC)"
	@echo "$(YELLOW)ðŸ’¡ Para importar: docker load < minikernel-dev.tar.gz$(NC)"

# Importar imagen desde archivo
import-image:
	@echo "$(YELLOW)ðŸ“¥ Importando imagen Docker...$(NC)"
	@test -f minikernel-dev.tar.gz || (echo "$(RED)âŒ Archivo minikernel-dev.tar.gz no encontrado$(NC)" && exit 1)
	docker load < minikernel-dev.tar.gz
	@echo "$(GREEN)âœ… Imagen importada$(NC)"